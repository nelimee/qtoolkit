# ======================================================================
# Copyright CERFACS (October 2018)
# Contributor: Adrien Suau (suau@cerfacs.fr)
#
# This software is governed by the CeCILL-B license under French law and
# abiding  by the  rules of  distribution of free software. You can use,
# modify  and/or  redistribute  the  software  under  the  terms  of the
# CeCILL-B license as circulated by CEA, CNRS and INRIA at the following
# URL "http://www.cecill.info".
#
# As a counterpart to the access to  the source code and rights to copy,
# modify and  redistribute granted  by the  license, users  are provided
# only with a limited warranty and  the software's author, the holder of
# the economic rights,  and the  successive licensors  have only limited
# liability.
#
# In this respect, the user's attention is drawn to the risks associated
# with loading,  using, modifying and/or  developing or reproducing  the
# software by the user in light of its specific status of free software,
# that  may mean  that it  is complicated  to manipulate,  and that also
# therefore  means that  it is reserved for  developers and  experienced
# professionals having in-depth  computer knowledge. Users are therefore
# encouraged  to load and  test  the software's  suitability as  regards
# their  requirements  in  conditions  enabling  the  security  of their
# systems  and/or  data to be  ensured and,  more generally,  to use and
# operate it in the same conditions as regards security.
#
# The fact that you  are presently reading this  means that you have had
# knowledge of the CeCILL-B license and that you accept its terms.
# ======================================================================

"""This module provides a trie adapted to quantum gates."""

import typing

import numpy

import qtoolkit.maths.matrix.su2.transformations as su2_trans
import qtoolkit.utils.types as qtypes


class QuantumGateLazyGenerator:

    def __init__(self, allowed_gates: typing.Sequence[qtypes.SU2Matrix],
                 depth: int, simplifiable_sequences: typing.Set[bytes],
                 max_simplifiable_length: int = None) -> None:
        """Initialise a QuantumGateLazyGenerator instance.

        :param allowed_gates: A list of basis matrices in **SU(2)**. The list is
        **not** expanded with inverses, so you should provide **all** the
        matrices that are in the basis.
        Warning: the number of allowed gate should not be above 255.
        :param depth: Length of the generated sequences of basis matrices.
        :param simplifiable_sequences: An efficient data structure for querying
        if a given gate sequence is simplifiable. The items in the set should be
        the results of calling numpy.ndarray.tobytes() on an array (with
        dtype=numpy.int8) representing the indexes of the gates that can be
        simplified.
        For example, if our basis is [H, T], numpy.array([0,0]).tobytes() can be
        in the set because H @ H is simplifiable to the identity.
        :param max_simplifiable_length: Maximum length of simplifiable gate
        sequences. The algorithm will not check for sequences above this length.
        If None, the value is computed with the given simplifiable_sequences.
        """
        # Initialise the depth of the lazy trie.
        assert depth > 0
        self._depth = depth
        # List the gates
        for gate in allowed_gates:
            assert numpy.isclose(numpy.linalg.det(gate), 1.0), (
                "There is at least one gate in your basis that is not in SU("
                "2).")
        self._gates = allowed_gates
        self._simplifiable_seqs = simplifiable_sequences
        self._max_simplifiable_length = max_simplifiable_length or max(
            map(len, self._simplifiable_seqs))

    def generate_all_possible_unitaries(self) -> typing.Iterable[
        typing.Tuple[numpy.ndarray, qtypes.SU2Matrix]]:
        """Yields all the unitary matrices generated by the given set of gates.

        The set of allowed gates given at the construction of the instance
        is used along with the set of inverses to generate all the possible
        unitary matrices.

        :return: A sequence of integers representing a sequence of gates and
        the associated unitary.
        """
        # Initialisation of the data structures used
        current_index = 0
        gate_sequence = numpy.zeros((self._depth,), dtype=numpy.int8)
        saved_matrices = numpy.zeros((self._depth, 2, 2), dtype=numpy.complex)

        # Go to the first leaf
        saved_matrices[0, :, :] = self._gates[0]
        # Leafs are at depth self._depth, i.e. index of self._depth - 1.
        while current_index < self._depth - 1:
            # Explore one level further
            current_index += 1
            # If we want to avoid useless branches, then pass them.
            gate_sequence, current_index = \
                self._go_to_first_non_simplifiable_branch(
                gate_sequence, current_index)
            if current_index == -1:
                # If the first non-simplifiable branch returns to the root
                # this means that there is no "useful" sequence of gates of
                # length self._depth.
                return
            if current_index == 0:
                # We went back to the first level so we need to update the
                # matrix.
                saved_matrices[0, :, :] = self._gates[
                    gate_sequence[current_index]]
                # We don't need to update an other matrix, so we just
                # go back to the beginning of the loop.
                continue
            # We are now on the branch we want to explore, then go down in the
            # tree, update the cached matrices and explore by looping!
            saved_matrices[current_index, :, :] = (
                saved_matrices[current_index - 1, :, :] @ self._gates[
                gate_sequence[current_index]])

        # Yield the result of the first leaf
        yield (gate_sequence, saved_matrices[-1, :, :])

        # Then explore until we finished to explore the tree.
        while True:
            # 1. Go to next leaf.
            # 1.1. Rewind until we can move right in the tree.
            gate_sequence, current_index = \
                self._go_to_next_non_simplifiable_branch(
                gate_sequence, current_index)
            # If we went back to the root, then the exploration is over.
            if current_index == -1:
                return
            if current_index == 0:
                # We went back to the first level so we need to update the
                # matrix.
                saved_matrices[0, :, :] = self._gates[
                    gate_sequence[current_index]]
            else:
                # Even if we are not at the root, we need to update a matrix.
                saved_matrices[current_index, :, :] = (
                    saved_matrices[current_index - 1, :, :] @ self._gates[
                    gate_sequence[current_index]])
            # 1.3 Explore new nodes up to the leaf and update the matrices.
            while current_index < self._depth - 1:
                # Go down
                current_index += 1
                # Go to the first non-simplifiable branch
                gate_sequence, current_index = \
                    self._go_to_first_non_simplifiable_branch(
                    gate_sequence, current_index)
                # If we went back to the root, then the exploration is over.
                if current_index == -1:
                    return
                if current_index == 0:
                    # We went back to the first level so we need to update the
                    # matrix.
                    saved_matrices[0, :, :] = self._gates[
                        gate_sequence[current_index]]
                else:
                    # Even if we are not at the root, we need to update a
                    # matrix.
                    saved_matrices[current_index, :, :] = (
                        saved_matrices[current_index - 1, :, :] @ self._gates[
                        gate_sequence[current_index]])
            # 2. Yield the result and loop-back
            yield (gate_sequence, saved_matrices[-1, :, :])

    def generate_all_possible_so3(self, prune_branches: bool = True) -> \
        typing.Iterable[typing.Tuple[typing.Sequence[int], qtypes.SU2Matrix]]:
        """Yields all the SO(3) vectors generated by the given set of gates.

        The set of allowed gates given at the construction of the instance
        is used along with the set of inverses to generate all the possible
        unitary matrices. These unitary matrices are then transformed to SO(3)
        rotations with the qtoolkit.maths.matrix.su2.transformation.su2_to_so3.

        :param prune_branches: If True, all gate sequence with U @ U.T.conj()
        (i.e. the indentity) will be pruned. If False, all the gate sequences
        are generated.
        :return: A sequence of integers representing a sequence of gates and
        the associated SO(3) vector.
        """

        def su2_to_so3(
            arg: typing.Tuple[typing.Sequence[int], qtypes.SU2Matrix]) -> \
            typing.Tuple[typing.Sequence[int], qtypes.SO3Vector]:
            return arg[0], su2_trans.su2_to_so3(arg[1])

        return map(su2_to_so3, self.generate_all_possible_unitaries())

    def _is_simplifiable(self, gate_sequence: numpy.ndarray,
                         current_index: int) -> bool:
        """Check is the given gate sequence is simplifiable.

        This function assumes that the given gate_sequence has already been
        checked for simplifiability up to the penultimate gate. This means that
        the only possible source of simplifiability is the last gate of the
        provided sequence.

        :param gate_sequence: The gate sequence to check.
        :param current_index: The depth of the last gate added.
        :return: True if the sequence is simplifiable, else False.
        """
        # Alias for readability
        ci = current_index

        for sl in range(1, min(self._max_simplifiable_length + 1, ci + 1)):
            if gate_sequence[
               ci - sl:ci + 1].tobytes() in self._simplifiable_seqs:
                return True
        return False

    def _go_to_first_non_simplifiable_branch(self, gate_sequence: numpy.ndarray,
                                             current_depth: int) -> \
        typing.Tuple[numpy.ndarray, int]:
        """Update the given state to move to the first non simplifiable branch.

        If the given state is already a non simplifiable branch, this function
        do nothing.

        :param gate_sequence: Sequence of gates as an array of indices.
        :param current_depth: Current depth in the tree traversal.
        :return: The state representing the next non simplifiable branch.
        """

        # If we are at the root, then this is the last leaf
        # If we are at depth 1, then there is only one gate and it can't be
        # simplified.
        if current_depth <= 0:
            return gate_sequence, current_depth

        while gate_sequence[current_depth] < len(
            self._gates) and self._is_simplifiable(gate_sequence,
                                                   current_depth):
            # We use the next gate
            gate_sequence[current_depth] += 1

        # If we found a suitable gate at the current level then we can return
        # the state.
        if gate_sequence[current_depth] < len(self._gates):
            return gate_sequence, current_depth
        # Else, we recurse by going up in the tree.
        else:
            # Clean for the next use
            gate_sequence[current_depth] = 0
            # Before recurring, update the gate above to avoid going back to the
            # same sequence.
            gate_sequence[current_depth - 1] += 1
            return self._go_to_first_non_simplifiable_branch(gate_sequence,
                                                             current_depth - 1)

    def _go_to_next_non_simplifiable_branch(self, gate_sequence: numpy.ndarray,
                                            current_depth: int) -> typing.Tuple[
        numpy.ndarray, int]:
        """Update the given state to move to the next non simplifiable branch.

        :param gate_sequence: Sequence of gates as an array of indices.
        :param current_depth: Current depth in the tree traversal.
        :return: The state representing the next non simplifiable branch.
        """
        # 1. Go to the next branch
        while current_depth != -1 and gate_sequence[current_depth] >= len(
            self._gates) - 1:
            # Clean for the next use.
            gate_sequence[current_depth] = 0
            current_depth -= 1
        # If we are at the root, then there is no next branch.
        if current_depth == -1:
            return gate_sequence, current_depth
        # Else, we go right and find the first non simplifiable sequence.
        gate_sequence[current_depth] += 1
        return self._go_to_first_non_simplifiable_branch(gate_sequence,
                                                         current_depth)
